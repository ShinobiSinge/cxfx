package gfx

// Globals ...
var g_octrees []Octree
var g_octreeCells []mat.v3

// Types ...
type Octree struct {
    debugMesh MeshId
    center mat.v3
    size mat.v3
    min mat.v3
    max mat.v3
    maxLevel i32
    centers []mat.v3
    sizes []mat.v3
    mins []mat.v3
    maxs []mat.v3
    corners []mat.v3
}

// OctreeId ...
type OctreeId struct {
    octree i32
}

// InvalidOctree ...
func InvalidOctree() (out OctreeId) {
    out.octree = -1
}

// OctreeIsValid ...
func OctreeIsValid(id OctreeId) (out bool) {
    out = id.octree >= 0 && id.octree < len(g_octrees)
}

// OctreeCreate ...
func OctreeCreate(min mat.v3, max mat.v3, maxLevel i32)(out OctreeId) {
    out.octree = len(g_octrees)

    var octree Octree
    octree.debugMesh = MeshCreate(LINES, UNSIGNED_SHORT, 10 * 8192 * 3, g_vertexLayout, 10 * 8192 * 3)
    octree.size = v3.mulf(v3.sub(max, min), 0.5)
    octree.center = v3.add(min, octree.size)
    octree.min = min
    octree.max = max
    octree.maxLevel = maxLevel

    g_octrees = append(g_octrees, octree)
    g_octreeCells = append(g_octreeCells, v3.make( 1.0,  1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0,  1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0, -1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make( 1.0, -1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0,  1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0,  1.0, -1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0, -1.0,  1.0))
    g_octreeCells = append(g_octreeCells, v3.make(-1.0, -1.0, -1.0))
    //octreeUpdate(out)
}

// OctreeUpdate ...
func OctreeUpdate(id OctreeId, frustum FrustumId) {
    panicIfNot(OctreeIsValid(id), "invalid id")
    MeshBegin(g_octrees[id.octree].debugMesh)
    octreeUpdateLevel(id, 0, g_octrees[id.octree].center, g_octrees[id.octree].size, frustum, true)
    MeshEnd(g_octrees[id.octree].debugMesh)
}

// OctreeRender ...
func OctreeRender(id OctreeId, world mat.m44, view mat.m44, projection mat.m44) {
    panicIfNot(OctreeIsValid(id), "invalid id")

    DepthState(true, LESS, false)
	EffectUse(g_fxVertexColor3D)
	EffectAssignM44(g_fxVertexColor3D, UNIFORM_WORLD, world, false)
	EffectAssignM44(g_fxVertexColor3D, UNIFORM_VIEW, view, false)
	EffectAssignM44(g_fxVertexColor3D, UNIFORM_PROJECTION, projection, false)
	MeshRender(g_octrees[id.octree].debugMesh)
}

func octreeUpdateLevel(id OctreeId, level i32, center mat.v3, size mat.v3, frustum FrustumId, debug bool) {
    var maxLevel i32 = g_octrees[id.octree].maxLevel
    if level <= maxLevel {
        var min mat.v3 = v3.sub(center, size)
        var max mat.v3 = v3.add(center, size)
        var inter i32 = BoxIntersectsFrustumVolume(min, max, frustum)
        var render bool
        var recurse bool

        if inter == 0 {
            if level == maxLevel {
                render = true
            } else {
                recurse = true
            }
        } else if inter == -1 {
            render = true
        } else if inter == 1 {
        }
    }

    if render && debug {
        MeshAppendBox(g_octrees[id.octree].debugMesh, true, false,
            center, v3.make(size.x, 0.0, 0.0), v3.make(0.0, size.y, 0.0), v3.make(0.0, 0.0, size.z),
            v4.GREEN)
    }

    if recurse {
        var childLevel i32 = level + 1
        var childSize mat.v3 = v3.mulf(size, 0.5)
        for i := 0; i < 8; i++ {
            octreeUpdateLevel(id, level + 1, v3.add(center, v3.mul(g_octreeCells[i], childSize)),
                childSize, frustum, debug)
        }
    }
}



